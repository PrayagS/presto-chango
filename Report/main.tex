\documentclass[12pt, a4paper]{IEEEtran}

\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{blindtext}

% \usepackage{listings}
% \usepackage{minted}
% \definecolor{DarkGray}{gray}{0.1}
% \usemintedstyle{pastie}
    
\begin{document}

\title{Music Identification through Audio Fingerprinting}

\author{
    \vspace{10mm}
    \huge
    Group 1 \\
    \vspace{3mm}
    \LARGE
    Yashraj Kakkad - \textit{AU1841036} \\ 
    Prayag Savsani - \textit{AU1841035} \\
    Yashil Depani - \textit{AU1841005} \\ 
    Harshil Mehta - \textit{AU1841010} \\
\vspace{3mm}
Guided by - Prof. Ashok Ranade \\
\null \vfill
*The photo goes here*
}

\input{titlepage}

\section{Objective}
The objective of the project is to recognize a song from an arbitrary 30 second sample through appropriate audio fingerprinting techniques.
To accomplish that, a number of songs are broken into chunks. The best frequencies across a spectrum are taken and they are hashed in an appropriate data structure.
The obtained input from the user undergoes a similar procedure and is then compared with the hash values of the song. The song which matches with the input the most is displayed as a result to the user.
\par
This was a very brief outline. The coming sections exactly explain what we have done.

\section{Sampling}
Music is typically sampled at 44.1 kHz. This is because of a theorem by Nyquist and Shannon which requires \(f_d >= 2f_s\) where \(f_d\) is the digital frequency and \(f_s\) is the sampling rate. The number, in practice, is greater than 2. Maximum sound frequency, as we know, is 20 kHz.
\par
We'll be using Fast Fourier Transform at a later stage to obtain the frequency spectrum of several chunks of the song. Running it on even a few hundred songs would take days.
Therefore, we downsample the recorded sample by a factor of 4. 
As a consequence, the maximum sound frequency in our audio sample comes down to 5kHz. This is not a problem as the frequency spectrum of most of the song lies below 5kHz. The gains are therefore much higher than the losses.

\section{Filtering}
Aliasing refers to the distortion that results when a signal reconstructed from samples is different from the original continuous signal.
We filter the high-end frequences before downsampling to avoid this phenomenon.

\section{Fast Fourier Transform}
Discrete Fourier Transform converts a signal from the time domain to the frequency domain. The formula is:
\begin{align*}
    X(n) = \sum_{k=0}^{N-1} x[k] e^{-j(2\pi kn/N)}
\end{align*}
Fast Fourier Transform is an algorithm that computes Discrete Fourier Transform. As the name says, it is "faster" than actual Discrete Fourier Transform. To make a comparison, Discrete Fourier Transform requires \(\mathcal{O}(N^2)\) while its counterpart only requires \(\mathcal{O}(NlogN)\), where N is the number of samples. This is a huge improvement since N is typically quite large in our case.\\
Speed is important in this case as the quicker we get the answer, the better experience we provide to the user.
Also, the database of songs to be maintained is large.

\vspace*{-2cm}
\section{Section Title}
\vspace*{-1cm}
\blindtext

\section{Section Title}
\blindtext

\pagebreak

% \onecolumn
% \begin{listing}[ht]
% \begin{minted}[
% frame=lines,
% framesep=2mm,
% breaklines=true
% ]{python}
% import numpy as np
    
% def incmatrix(genl1,genl2):
%     m = len(genl1)
%     n = len(genl2)
%     M = None #to become the incidence matrix asdasdfasdfsadfsdfsdafsadfsdfasdsfsdafsdfsadfsadfsdafsdfsadfsadfdsfsdafsadfsadfsadfsadfsdafsdafsadfsadfsadfsadfasdfsadfasdfasdfsadfsadfasdfsadfasdfsdafasdfsadfsadfsdafsadf
%     VT = np.zeros((n*m,1), int)  #dummy variable
    
%     #compute the bitwise xor matrix
%     M1 = bitxormatrix(genl1)
%     M2 = np.triu(bitxormatrix(genl2),1) 

%     for i in range(m-1):
%         for j in range(i+1, m):
%             [r,c] = np.where(M2 == M1[i,j])
%             for k in range(len(r)):
%                 VT[(i)*n + r[k]] = 1;
%                 VT[(i)*n + c[k]] = 1;
%                 VT[(j)*n + r[k]] = 1;
%                 VT[(j)*n + c[k]] = 1;
                
%                 if M is None:
%                     M = np.copy(VT)
%                 else:
%                     M = np.concatenate((M, VT), 1)
                
%                 VT = np.zeros((n*m,1), int)
    
%     return M
% \end{minted}
% \caption{Minimal working example}
% \end{listing}

% \twocolumn
% \section{Section Title}
% \blindtext

\end{document}